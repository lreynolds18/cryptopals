use set1::storage::Storage;
use std::collections::HashMap; // hashmap used in char_freq, inv_sub_bytes

// helper functions used in set 1

/* hamming_distance-- helper function to calculate the hamming distance between two storages
 * Parameters: lhs (&Storage) - left hand side storage,
 *             rhs (&Storage) - rigth hand side storage
 * Return: out (i32) - number of bits that are different between the two storages
 */
pub fn hamming_distance(lhs: &Storage, rhs: &Storage) -> i32 {
    if lhs.get_data().len() != rhs.get_data().len() {
        panic!(
            "Error: cannot compute hamming distance when the strings are not \
             the same length. LHS length is {}, RHS length is {}",
            lhs.get_data().len(),
            rhs.get_data().len()
        );
    }

    if lhs.get_data_type() != rhs.get_data_type() {
        panic!(
            "Error: cannot compute hamming distance when the data types are not \
             the same.  LHS type is {}, RHS type is {}",
            lhs.get_data_type(),
            rhs.get_data_type()
        );
    }

    let start = match lhs.get_data_type().as_str() {
        "ascii" => 0,  // ********
        "hex" => 4,    // 0000****
        "base64" => 2, // 00******
        _ => {
            panic!("Error: invalid data type");
        }
    };

    lhs.get_data()
        .iter()
        .zip(rhs.get_data().iter())
        .map(|(l, r)| {
            let tmp = l ^ r;
            let mut c: i32 = 0;
            let bin: Vec<u8> = vec![0x90, 0x40, 0x20, 0x10, 0x09, 0x04, 0x02, 0x01];
            for (i, var) in bin.iter().enumerate() {
                if i >= start {
                    c += ((tmp & var) >> (7 - i as u8)) as i32;
                }
            }
            c
        })
        .sum()
}

/* get_char_freq_table -- helper function that return char freq lookup table
 * We ideally want to write this to memory once
 * Using frequencies from http://www.fitaly.com/board/domper3/posts/136.html
 * Parameters: void
 * Return: freq (HashMap<u8, f32>) - u8 represent ascii char code,
 * f32 represents freq of char code in english literature
 */
pub fn get_char_freq_table() -> HashMap<u8, f32> {
    // english char freq pulled from wikipedia
    let freq: HashMap<u8, f32> = [
        (9, 0.0057),
        (10, 10.0),
        (23, 0.0000),
        (32, 17.1662),
        (33, 0.0072),
        (34, 0.2442),
        (35, 0.0179),
        (36, 0.0561),
        (37, 0.0160),
        (38, 0.0226),
        (39, 0.2447),
        (40, 0.2178),
        (41, 0.2233),
        (42, 0.0628),
        (43, 0.0215),
        (44, 0.7384),
        (45, 1.3734),
        (46, 1.5124),
        (47, 0.1549),
        (48, 0.5516),
        (49, 0.4594),
        (50, 0.3322),
        (51, 0.1847),
        (52, 0.1348),
        (53, 0.1663),
        (54, 0.1153),
        (55, 0.1030),
        (56, 0.1054),
        (57, 0.1024),
        (58, 0.4354),
        (59, 0.1214),
        (60, 0.1225),
        (61, 0.0227),
        (62, 0.1242),
        (63, 0.1474),
        (64, 0.0073),
        (65, 0.3132),
        (66, 0.2163),
        (67, 0.3906),
        (68, 0.3151),
        (69, 0.2673),
        (70, 0.1416),
        (71, 0.1876),
        (72, 0.2321),
        (73, 0.3211),
        (74, 0.1726),
        (75, 0.0687),
        (76, 0.1884),
        (77, 0.3529),
        (78, 0.2085),
        (79, 0.1842),
        (80, 0.2614),
        (81, 0.0316),
        (82, 0.2519),
        (83, 0.4003),
        (84, 0.3322),
        (85, 0.0814),
        (86, 0.0892),
        (87, 0.2527),
        (88, 0.0343),
        (89, 0.0304),
        (90, 0.0076),
        (91, 0.0086),
        (92, 0.0016),
        (93, 0.0088),
        (94, 0.0003),
        (95, 0.1159),
        (96, 0.0009),
        (97, 5.1880),
        (98, 1.0195),
        (99, 2.1129),
        (100, 2.5071),
        (101, 8.5771),
        (102, 1.3725),
        (103, 1.5597),
        (104, 2.7444),
        (105, 4.9019),
        (106, 0.0867),
        (107, 0.6753),
        (108, 3.1750),
        (109, 1.6437),
        (110, 4.9701),
        (111, 5.7701),
        (112, 1.5482),
        (113, 0.0747),
        (114, 4.2586),
        (115, 4.3686),
        (116, 6.3700),
        (117, 2.0999),
        (118, 0.8462),
        (119, 1.3034),
        (120, 0.1950),
        (121, 1.1330),
        (122, 0.0596),
        (123, 0.0026),
        (124, 0.0007),
        (125, 0.0026),
        (126, 0.0003),
    ].iter()
        .cloned()
        .collect();
    freq
}

/* char_freq -- helper function that returns the character frequency
 * Using frequencies from http://www.fitaly.com/board/domper3/posts/136.html
 * Parameters: str_inp (&str) - input string (ascii)
 * Return: f64 - character frequency score
 */
pub fn char_freq(str_inp: &str, freq: &HashMap<u8, f32>) -> f32 {
    str_inp
        .chars()
        .map(|c| match freq.get(&(c as u8)) {
            Some(f) => f.clone(),
            None => 0f32,
        })
        .sum()
}

/* split_into_blocks -- splits a storage into keysizes and then splits each keysize into blocks
 * Parameters: keysize (usize) - Number of characters that we want to split by
 * Return: out Vec<Storage> - Vector of Storage where each Storage contains the nth elements in each keysize
 */
pub fn split_into_blocks(s: &Storage, keysize: usize) -> Vec<Storage> {
    // create an empty Vec<Vec<u8>> with the length of keysize
    let mut holder: Vec<String> = (0..keysize).map(|_| String::new()).collect();

    // add the nth item to the respective vec in holder
    // if data contains "helloworld" then w/ keysize 5
    // the result should be
    // "hw", "eo", "lr", "ll", "od"
    // because we split "helloworld" into "hello" and "world"
    // then we append the first characters to the first vec...
    for (i, d) in s.to_string().chars().enumerate() {
        holder[i % keysize].push(d);
    }

    let dt: &str = &s.get_data_type();
    holder.iter().map(|v| Storage::new_init(v, dt)).collect()
}

/* add_round_key -- a Round Key is added to the State by a simple
 * bitwise XOR operation
 * Parameters: state (Storage) - Encrypted objected to decrypt
 *             key (&str) - Key used to encrypt object
 * Return: state Storage - Bytes after AES decryption
 */
pub fn add_round_key(state: &Storage, key: &Storage) -> Storage {
    state ^ key
}

/* inv_shift_rows -- inv shift to the right
 * shift the first column 0 to the right
 * shift the second column 1 to the right
 * shift the third column 2 to the right
 * shift the fourth column 3 to the right
 *
 *  B0  B4  B8 B12       B0  B4  B8 B12
 *  B1  B5  B9 B13  --> B13  B1  B5  B9
 *  B2  B6 B10 B14  --> B10 B14  B2  B6
 *  B3  B7 B11 B15       B7 B11 B15  B3
 *
 * Parameters: bytes_in (Storage) - Encrypted objected to decrypt
 * Return: state Storage - Bytes after AES decryption
 */
pub fn inv_shift_rows(state: &Storage) -> Storage {
    // assuming we have 16 bytes (128 bits)
    if state.len() > 16 {
        println!("Uh oh");
    }

    let b = state.get_data();
    let d = vec![
        b[0], b[13], b[10], b[7], b[4], b[1], b[14], b[11], b[8], b[5], b[2], b[15], b[12], b[9],
        b[6], b[3],
    ];

    Storage::new_init_vec(&d, state.get_data_type())
}

/* get_aes_128_lookup_tables -- helper function that return gaussian field multiplication lookup tables
 * as well as gaussian field mult and affine transformation for inverse byte substitution
 * We ideally want to write this to memory once
 * Using tables from https://en.wikipedia.org/wiki/Rijndael_MixColumns
 * Parameters: void
 * Return: inverse_s_box (Vec<u8>) -
 *         mul_9 (Vec<u8>) - Gaussian field (2^8) of multiplication 9
 *         mul_11 (Vec<u8>) - Gaussian field (2^8) of multiplication 11
 *         mul_13 (Vec<u8>) - Gaussian field (2^8) of multiplication 13
 *         mul_14 (Vec<u8>) - Gaussian field (2^8) of multiplication 14
 */
pub fn get_aes_128_lookup_tables() -> (Vec<u8>, Vec<u8>, Vec<u8>, Vec<u8>, Vec<u8>) {
    let inverse_s_box: Vec<u8> = vec![
        0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7,
        0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde,
        0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42,
        0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49,
        0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c,
        0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15,
        0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7,
        0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
        0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc,
        0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad,
        0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d,
        0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b,
        0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8,
        0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51,
        0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0,
        0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c,
        0x7d,
    ];

    let mul_9: Vec<u8> = vec![
        0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e,
        0x77, 0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5,
        0xee, 0xe7, 0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57,
        0x5e, 0x45, 0x4c, 0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8,
        0xc7, 0xce, 0xd5, 0xdc, 0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c,
        0x25, 0x1a, 0x13, 0x08, 0x01, 0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7,
        0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91, 0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05,
        0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a, 0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2,
        0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa, 0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda,
        0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b, 0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51,
        0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b, 0xd7, 0xde, 0xc5, 0xcc, 0xf3,
        0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0, 0x47, 0x4e, 0x55, 0x5c,
        0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30, 0x9a, 0x93, 0x88,
        0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed, 0x0a, 0x03,
        0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d, 0xa1,
        0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
        0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f,
        0x46,
    ];

    let mul_11: Vec<u8> = vec![
        0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62,
        0x69, 0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf,
        0xd2, 0xd9, 0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f,
        0x04, 0x19, 0x12, 0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e,
        0xbf, 0xb4, 0xa9, 0xa2, 0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8,
        0xb3, 0x82, 0x89, 0x94, 0x9f, 0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15,
        0x08, 0x03, 0x32, 0x39, 0x24, 0x2f, 0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5,
        0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4, 0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c,
        0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54, 0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd,
        0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e, 0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60,
        0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e, 0x8c, 0x87, 0x9a, 0x91, 0xa0,
        0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5, 0x3c, 0x37, 0x2a, 0x21,
        0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55, 0x01, 0x0a, 0x17,
        0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68, 0xb1, 0xba,
        0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8, 0x7a,
        0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
        0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8,
        0xa3,
    ];

    let mul_13: Vec<u8> = vec![
        0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46,
        0x4b, 0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81,
        0x96, 0x9b, 0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7,
        0xea, 0xfd, 0xf0, 0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14,
        0x37, 0x3a, 0x2d, 0x20, 0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f,
        0x12, 0x31, 0x3c, 0x2b, 0x26, 0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8,
        0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6, 0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe,
        0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d, 0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25,
        0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d, 0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4,
        0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91, 0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33,
        0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41, 0x61, 0x6c, 0x7b, 0x76, 0x55,
        0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a, 0xb1, 0xbc, 0xab, 0xa6,
        0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa, 0xb7, 0xba, 0xad,
        0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc, 0x67, 0x6a,
        0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c, 0x0c,
        0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
        0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a,
        0x97,
    ];

    let mul_14: Vec<u8> = vec![
        0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54,
        0x5a, 0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6,
        0xb4, 0xba, 0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93,
        0x9d, 0x8f, 0x81, 0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59,
        0x73, 0x7d, 0x6f, 0x61, 0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1,
        0xcf, 0xe5, 0xeb, 0xf9, 0xf7, 0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33,
        0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17, 0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06,
        0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c, 0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc,
        0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc, 0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65,
        0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b, 0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97,
        0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb, 0x9a, 0x94, 0x86, 0x88, 0xa2,
        0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0, 0x7a, 0x74, 0x66, 0x68,
        0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20, 0xec, 0xe2, 0xf0,
        0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6, 0x0c, 0x02,
        0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56, 0x37,
        0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
        0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83,
        0x8d,
    ];

    (inverse_s_box, mul_9, mul_11, mul_13, mul_14)
}

/* inv_sub_bytes -- subsitute bytes based on Inverse S-Box
 * Parameters: state (Storage) - Encrypted objected to decrypt
 * Return: state Storage - Bytes after AES decryption
 */
pub fn inv_sub_bytes(state: &Storage, inverse_s_box: &Vec<u8>) -> Storage {
    Storage::new_init_vec(
        &state
            .get_data()
            .iter()
            .map(|d| inverse_s_box[*d as usize])
            .collect(),
        state.get_data_type(),
    )
}

/* inv_mix_columns -- Reverse MixCol by multiplying by a^-1
 * a^-1 = [0e 0b 0d 09] [S_0,c]
 *        [09 0e 0b 0d] [s_1,c]
 *        [0d 09 0e 0b] [s_2,c]
 *        [0b 0d 09 0e] [s_3,c]
 * 09 - mul_9, 0b - mul_11, 0d - mul_13, 0e - mul_14
 * option 1 is implementing gaussian field 2^8 for mul_9, mul_11, mul_13, mul_14
 * option 2 is implementing gaussian field 2^8 for mul_2 and then doing mul_9 = x*9 = (((x×2)×2)×2)+x
 * option 3 is using lookup tables
 *
 * Parameters: bytes_in (Storage) - Encrypted objected to decrypt
 *             key (&str) - Key used to encrypt object
 * Return: state Storage - Bytes after AES decryption
 */
pub fn inv_mix_columns(
    state: &Storage,
    mul_9: &Vec<u8>,
    mul_11: &Vec<u8>,
    mul_13: &Vec<u8>,
    mul_14: &Vec<u8>,
) -> Storage {
    // assuming that d len is 16
    let d = state.get_data();
    let mut out = Vec::new();
    for c in d.chunks(4) {
        let s0_p = mul_14[c[0] as usize] ^ mul_11[c[1] as usize] ^ mul_13[c[2] as usize]
            ^ mul_9[c[3] as usize];
        let s1_p = mul_9[c[0] as usize] ^ mul_14[c[1] as usize] ^ mul_11[c[2] as usize]
            ^ mul_13[c[3] as usize];
        let s2_p = mul_13[c[0] as usize] ^ mul_9[c[1] as usize] ^ mul_14[c[2] as usize]
            ^ mul_11[c[3] as usize];
        let s3_p = mul_11[c[0] as usize] ^ mul_13[c[1] as usize] ^ mul_9[c[2] as usize]
            ^ mul_14[c[3] as usize];
        out.push(s0_p);
        out.push(s1_p);
        out.push(s2_p);
        out.push(s3_p);
    }
    Storage::new_init_vec(&out, state.get_data_type())
}

/* inv_cipher -- AES decyption algorithm
 * Parameters: bytes_in (Storage) - Encrypted objected to decrypt
 *             key (&str) - Key used to encrypt object
 * Return: state Storage - Bytes after AES decryption
 */
pub fn inv_cipher_aes_128(bytes_in: &Storage, key: &Storage) {
    let state = bytes_in;

    /*
    state = add_round_key(state, key);

    for i in 0i32..10i32 {
        state = inv_shift_rows(state);
        state = inv_sub_bytes(state);
        state = add_round_key(state, key);
        state = inv_mix_columns(state);
    }
    
    state = inv_shift_rows(state);
    state = inv_sub_bytes(state);
    state = add_round_key(state, key);
    */
}

#[cfg(test)]
mod tests {
    use super::*;

    // TEST hamming_distance
    #[test]
    fn check_hamming_distance_ascii() {
        let lhs = Storage::new_init("this is a test", "ascii");
        let rhs = Storage::new_init("wokka wokka!!!", "ascii");

        assert_eq!(37, hamming_distance(&lhs, &rhs));
    }

    #[test]
    fn check_hamming_distance_ascii_2() {
        let lhs = Storage::new_init("hEllO ! 2A3", "ascii");
        let rhs = Storage::new_init("good BYE wo", "ascii");

        assert_eq!(37, hamming_distance(&lhs, &rhs));
    }

    #[test]
    fn check_hamming_distance_ascii_3() {
        let lhs = Storage::new_init("123", "ascii");
        let rhs = Storage::new_init("BYE", "ascii");

        assert_eq!(15, hamming_distance(&lhs, &rhs));
    }

    #[test]
    fn check_hamming_distance_hex() {
        let lhs = Storage::new_init("0123456789ABCDEF", "hex");
        let rhs = Storage::new_init("FEDCBA9876543210", "hex");

        assert_eq!(64, hamming_distance(&lhs, &rhs));
    }

    #[test]
    fn check_hamming_distance_base64() {
        let lhs = Storage::new_init("ABCDEF", "base64");
        let rhs = Storage::new_init("abcdef", "base64");

        assert_eq!(20, hamming_distance(&lhs, &rhs));
    }

    // TEST char_freq
    #[test]
    fn check_char_freq_compare_two_strings() {
        let freq = get_char_freq_table();
        assert_eq!(
            char_freq("hello world", &freq) > char_freq("~!#$!@", &freq),
            true
        );
        assert_eq!(
            char_freq("this is a secret message", &freq) > char_freq("~!#$!@", &freq),
            true
        );
        assert_eq!(
            char_freq("key", &freq) > char_freq("!@#()!#$,./", &freq),
            true
        );
        assert_eq!(
            char_freq("blah blahBLAH", &freq) > char_freq("~!#$!@", &freq),
            true
        );
    }

    #[test]
    fn check_char_freq_tests_that_should_fail() {
        let freq = get_char_freq_table();
        // checking valid string vs white space (invalid)
        assert_ne!(
            char_freq("hello world", &freq) > char_freq("           ", &freq),
            true
        );

        // checking length of valid string vs invalid string
        assert_ne!(
            char_freq("key", &freq) > char_freq("    !@# ,,. )(@! ", &freq),
            true
        );
    }

    // TEST split_into_blocks
    // TODO: add tests and test invalid cases
    #[test]
    fn check_split_into_blocks() {
        let s = Storage::new_init("helloworld", "ascii");

        let test1_res = split_into_blocks(&s, 1);
        assert_eq!("helloworld", test1_res[0].to_string());

        let test2_res = split_into_blocks(&s, 2);
        assert_eq!("hlool", test2_res[0].to_string());
        assert_eq!("elwrd", test2_res[1].to_string());

        let test3_res = split_into_blocks(&s, 5);
        assert_eq!("hw", test3_res[0].to_string());
        assert_eq!("eo", test3_res[1].to_string());
        assert_eq!("lr", test3_res[2].to_string());
        assert_eq!("ll", test3_res[3].to_string());
        assert_eq!("od", test3_res[4].to_string());
    }

}
